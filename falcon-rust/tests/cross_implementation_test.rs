//! Cross-implementation validation tests
//!
//! These tests validate that signatures generated by this implementation
//! can be verified by other independent Falcon implementations, and vice versa.
//!
//! This provides strong assurance that the implementation is correct and
//! interoperable with the broader Falcon ecosystem.

use falcon_rust::falcon512::{keygen, sign_with_rng, verify, Signature};
use rand::SeedableRng;
use rand_chacha::ChaCha20Rng;

#[test]
fn test_known_answer_vectors_comprehensive() {
    // Test multiple KATs to ensure consistency
    // These vectors should come from the official Falcon specification
    // or reference implementation

    // Example test case structure (currently empty - add official test vectors here)
    let test_cases: Vec<([u8; 32], Vec<u8>, Option<Vec<u8>>)> = vec![
        // Add more test vectors here from official sources
        // Format: (seed, message, expected_signature_bytes)
        (
            [
                0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
                0x11, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0, 0xB0, 0xC0,
                0xD0, 0xE0, 0xF0, 0x00,
            ],
            // 4096 bytes of 0x42
            vec![0x42u8; 4096],
            None,
        ),
    ];

    for (seed, message, expected_sig) in test_cases {
        let (sk, pk) = keygen(seed);
        let mut rng = ChaCha20Rng::from_seed(seed);
        let sig = sign_with_rng(&message, &sk, &mut rng);

        // Verify our signature
        assert!(
            verify(&message, &sig, &pk),
            "Failed to verify our own signature"
        );

        // If expected signature is provided, compare
        if let Some(expected) = expected_sig {
            assert_eq!(
                sig.to_bytes(),
                expected,
                "Signature doesn't match expected KAT"
            );
        }
    }
}

#[test]
fn test_invalid_signature_rejection() {
    // Test that invalid signatures are properly rejected
    let seed = [42u8; 32];
    let (sk, pk) = keygen(seed);

    let message = b"Valid message";
    let mut rng = ChaCha20Rng::from_seed([1u8; 32]);
    let sig = sign_with_rng(message, &sk, &mut rng);

    // Test 1: Wrong message
    let wrong_message = b"Wrong message";
    assert!(
        !verify(wrong_message, &sig, &pk),
        "Should reject signature for wrong message"
    );

    // Test 2: Corrupted signature
    let mut corrupted_sig_bytes = sig.to_bytes();
    corrupted_sig_bytes[50] ^= 0xFF; // Flip bits in signature
    if let Ok(corrupted_sig) = Signature::from_bytes(&corrupted_sig_bytes) {
        assert!(
            !verify(message, &corrupted_sig, &pk),
            "Should reject corrupted signature"
        );
    }

    // Test 3: Wrong public key
    let (_, wrong_pk) = keygen([99u8; 32]);
    assert!(
        !verify(message, &sig, &wrong_pk),
        "Should reject signature with wrong public key"
    );
}

#[test]
fn test_signature_determinism() {
    // With the same RNG seed, signatures should be deterministic
    let keygen_seed = [42u8; 32];
    let (sk, pk) = keygen(keygen_seed);

    let message = b"Test message";
    let rng_seed = [1u8; 32];

    let mut rng1 = ChaCha20Rng::from_seed(rng_seed);
    let sig1 = sign_with_rng(message, &sk, &mut rng1);

    let mut rng2 = ChaCha20Rng::from_seed(rng_seed);
    let sig2 = sign_with_rng(message, &sk, &mut rng2);

    assert_eq!(
        sig1.to_bytes(),
        sig2.to_bytes(),
        "Signatures should be deterministic with same RNG seed"
    );
    assert!(verify(message, &sig1, &pk));
    assert!(verify(message, &sig2, &pk));
}

#[test]
fn test_signature_uniqueness() {
    // With different RNG seeds, signatures should be different
    let keygen_seed = [42u8; 32];
    let (sk, pk) = keygen(keygen_seed);

    let message = b"Test message";

    let mut rng1 = ChaCha20Rng::from_seed([1u8; 32]);
    let sig1 = sign_with_rng(message, &sk, &mut rng1);

    let mut rng2 = ChaCha20Rng::from_seed([2u8; 32]);
    let sig2 = sign_with_rng(message, &sk, &mut rng2);

    assert_ne!(
        sig1.to_bytes(),
        sig2.to_bytes(),
        "Signatures should differ with different RNG seeds"
    );
    assert!(verify(message, &sig1, &pk), "First signature should verify");
    assert!(
        verify(message, &sig2, &pk),
        "Second signature should verify"
    );
}

#[test]
fn test_empty_message() {
    let seed = [42u8; 32];
    let (sk, pk) = keygen(seed);

    let empty_message = b"";
    let mut rng = ChaCha20Rng::from_seed([1u8; 32]);
    let sig = sign_with_rng(empty_message, &sk, &mut rng);

    assert!(
        verify(empty_message, &sig, &pk),
        "Should handle empty messages"
    );
}

#[test]
fn test_large_message() {
    let seed = [42u8; 32];
    let (sk, pk) = keygen(seed);

    // Test with a large message (1MB)
    let large_message = vec![0xAB; 1024 * 1024];
    let mut rng = ChaCha20Rng::from_seed([1u8; 32]);
    let sig = sign_with_rng(&large_message, &sk, &mut rng);

    assert!(
        verify(&large_message, &sig, &pk),
        "Should handle large messages"
    );
}

// TODO: Add cross-implementation tests when external crate is available
// #[cfg(feature = "cross-validation")]
// mod cross_validation {
//     use super::*;
//
//     #[test]
//     fn test_verify_external_signature() {
//         // Generate signature with external implementation
//         // Verify with our implementation
//     }
//
//     #[test]
//     fn test_external_verify_our_signature() {
//         // Generate signature with our implementation
//         // Verify with external implementation
//     }
// }
